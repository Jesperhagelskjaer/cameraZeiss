clear
%close all
% Generated by http://www.micromodeler.com/dsp/ using Frequency Sampling (Inverse DFT)
%% ###########################################################
% The length, or number of taps of the filter
filter1.length=60; %Filter order
filter1.fs=30000; %Samplings frequency Hz
filter1.groupDelay=(filter1.length/2)/filter1.fs; %Group delay in sec.
filter1.fc1=200; %Frequency cut 1 (start of bandpass) 300Hz
filter1.fc2=6000; %Frequency cut 2 (end of bandpass) Hz
filter1.fc3=10000;
filter1.gain = 1.0;
wc1 = (filter1.fc1/filter1.fs)*2;
wc2 = (filter1.fc2/filter1.fs)*2;
wc3 = (filter1.fc3/filter1.fs)*2;
% The frequencies at the band edges
filter1.frequencies = [ 0, wc1, wc2, wc3, 1 ]; 
	
% The desired response
filter1.desired = [ 0, 1, 1, 0, 0 ];

% Design the filter using the frequency sampling method with a Hamming window
%filter1.numerator = fir2( filter1.length-1, filter1.frequencies, filter1.desired, rectwin(filter1.length) ); % b coefficients
filter1.numerator = fir2( filter1.length-1, filter1.frequencies, filter1.desired, hamming(filter1.length) ) * filter1.gain; % b coefficients, hann, hamming, blackman
%filter1.numerator = firls( filter1.length-1, filter1.frequencies, filter1.desired, 'hilbert'); %, hamming(filter1.length) ); % b coefficients, hann, hamming, blackman
%b = firls(255,[0 0.25 0.3 1],[1 1 0 0]);
%Num_coeffs = firpm(filter1.length-1, filter1.frequencies, filter1.desired,'h');
%filter1.numerator = dfilt.dfasymfir(Num_coeffs);
%Num_coeffs = firpm(59,[0 .02 .4 1],[0 1 1 0],'h');
%Hd = dfilt.dfasymfir(filter1.numerator);
%impz(Hd)
%filter1.numerator = Hd.numerator;

%###########################################################
%# Export of coefficients, poles and zeros produced by MicroModeler DSP
% The numerator and denominator of the filter      
%filter1.gain = 1;
%filter1.numerator1 	= [0.001236, 0.004143, 0.007331, 0.00471, -0.002793, 0.014956, 0.094644, 0.205582, 0.235049, 0.10597, -0.10597, -0.235049, -0.205582, -0.094644, -0.014956, 0.002793, -0.00471, -0.007331, -0.004143, -0.001236] * filter1.gain;

%############################################################
%## Export of coefficients, poles and zeros produced by MicroModeler DSP
%# The numerator and denominator of the filter      
%filter1.gain = 1;
%filter1.numerator 	= [-0.000949, -0.008065, -0.0177, -0.010472, 0.006642, -0.025408, -0.10368, -0.085155, 0.125268, 0.361594, 0.361594, 0.125268, -0.085155, -0.10368, -0.025408, 0.006642, -0.010472, -0.0177, -0.008065, -0.000949] * filter1.gain;

filter1.denominator = 1; % a coefficients
filter1.p_poles = roots( filter1.denominator );
filter1.z_zeros = roots( filter1.numerator );
%filter1.z_zeros = [filter1.z_zeros; 1+0*i]; % Add zero in 1 and -1
%filter1.numerator = poly(filter1.z_zeros);

fvtool(filter1.numerator,filter1.denominator,'OverlayedAnalysis','phase')


%% ###########################################################
%# Filter analysis code
% Calculate the frequencies of interest      
filter1.frequencies = linspace( 0, 1, 512 );


% Calculate the complex frequency response      
filter1.cmplx = freqz( filter1.numerator, filter1.denominator, filter1.frequencies * pi );


% Calculate the magnitude of the frequency response
filter1.magnitude = abs( filter1.cmplx );


% Calculate the phase response      
filter1.phase = angle( filter1.cmplx );
% filter1.phase = unwrap( arg( filter1.cmplx ) );


% Calculate the group delay      
filter1.delay = grpdelay( filter1.numerator, filter1.denominator, filter1.frequencies );


% Calculate the impulse response      
filter1.impulse = filter( filter1.numerator, filter1.denominator, [1, zeros(1,127)] );


% Calculate the step response      
filter1.step = filter( filter1.numerator, filter1.denominator, ones(1,128) );


%% ###########################################################
%# Generate graphs
% The frequency vs magnitude graph
figure(2)
subplot( 3, 2, 1 );plot( filter1.frequencies, 	filter1.magnitude );
xlabel('Normalized Frequency');
ylabel('Magnitude');
title( 'Magnitude' );
      
% The frequency vs phase graph
subplot( 3, 2, 3 );
plot( filter1.frequencies, 	unwrap( filter1.phase ) );
xlabel('Normalized Frequency');
ylabel('Phase');
title( 'Phase' );


% The frequency vs group delay graph
subplot( 3, 2, 5 );
plot( filter1.frequencies, 	filter1.delay );
title( 'Group Delay (samples)' );
xlabel('Normalized Frequency');
ylabel('Group Delay');
      
% The impulse response vs time graph
subplot( 3, 2, 2 );
stem( filter1.impulse );
title( 'Impulse Response' );
xlabel('Time (Samples)');
ylabel('Impulse Response');
      
subplot( 3, 2, 4 );
stem( filter1.step );     
title( 'Step Response' );
xlabel('Time (Samples)');
ylabel('Step Response');


% z-plane plot (poles and zeros)
subplot( 3, 2, 6 );
zplane( filter1.z_zeros, filter1.p_poles );
title( 'Poles and Zeros' );

%z-plane plot (Coefficients)
%figure
%zplane( filter1.numerator, filter1.denominator );

figure(3)
b = filter1.numerator
a = filter1.denominator
stem(b);
title('FIR filter coefficients');
filter1
figure(4)
freqz(filter1.numerator, filter1.denominator)
title('FIR frequency response');

SaveFilterHeaderFile(b, filter1.fc1, 'FilterCoeffs_test.h');

%% Save coefficeints to header file
%
% Fs = 30000;
% F1 = 300; % Hz
% F2 = 8000; % Hz
% n = 6; % Order of butterworth filter
% fpass = [F1 F2];
% [b,a] = butter(n,fpass*2/Fs);

load 'simulation_parameters.mat'
%deltaf = fs/size(waves,1)
for i=1:76
    w = waves(:,:,i);
    w = [w; zeros(size(w)); zeros(size(w))]; % Zero padding
    n = 0.03*randn(size(w)); % 0.3 standard variation of noise
    ws = w+n;
    y = filter(b,a,ws);%zeros(size(w))
    W = abs(fft(ws));
    WS = sum(W');
    Y = abs(fft(y));
    YS = sum(Y');
    fx = (1:size(y,1)).*(filter1.fs/size(y,1));
    figure(5), 
    subplot(2,1,1);
    surf(ws); %ws,W
    title('Frequency response of template and noise');
    subplot(2,1,2);
    surf(y); %y,Y
    title('Frequency response of filtered template and noise');
    figure(6)
    %subplot(2,1,1);
    plot(fx, WS);
    xlabel('frequency');
    title('Frequency response of template and noise (SUM of channels) (red-filtered)');
    %subplot(2,1,2);
    hold on;
    plot(fx, YS, 'r');
    hold off;
    
    pause(0.1)
end

